"""PathPilot/LinuxCNC NGC post-processor for Tormach mills.

Generates .ngc files that are directly loadable by PathPilot.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional

from ..core.toolpath.base import MoveType, Toolpath, ToolpathPoint
from ..core.units import Units
from .gcode_writer import comment, linear, rapid, fmt


@dataclass
class PostProcessorConfig:
    """Configuration for the PathPilot post-processor."""

    units: Units = Units.INCH
    tool_number: int = 1
    rpm: int = 3000
    coolant: bool = True                # M8 / M9
    work_offset: str = "G54"            # G54â€“G59
    path_blend_tolerance: float = 0.002  # G64 P value (same units as job)
    safe_z: float = 0.5                  # inter-cut safe height
    rapid_z: float = 1.0                 # inter-op rapid clearance height
    program_number: Optional[int] = None  # O-word, None = omit
    spindle_warmup_dwell: float = 2.0    # G4 P seconds after spindle start


class PathPilotPostProcessor:
    """Translate a Toolpath into PathPilot-compatible G-code lines."""

    def __init__(self, config: PostProcessorConfig):
        self.cfg = config
        self._lines: list[str] = []
        self._current_feed: Optional[float] = None

    # ------------------------------------------------------------------
    # Public interface
    # ------------------------------------------------------------------

    def generate(
        self,
        toolpaths: list[Toolpath],
        output_path: Path,
    ) -> None:
        """Write G-code for *toolpaths* to *output_path*.

        Parameters
        ----------
        toolpaths:
            Ordered list of Toolpath objects (one per operation).
        output_path:
            Destination .ngc file.  Parent directories are created if needed.
        """
        self._lines = []
        self._current_feed = None

        self._write_preamble()

        for tp in toolpaths:
            self._write_toolpath(tp)

        self._write_postamble()

        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text("\n".join(self._lines) + "\n")

    def get_lines(self, toolpaths: list[Toolpath]) -> list[str]:
        """Return G-code lines without writing to disk (useful for testing)."""
        self._lines = []
        self._current_feed = None
        self._write_preamble()
        for tp in toolpaths:
            self._write_toolpath(tp)
        self._write_postamble()
        return list(self._lines)

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _emit(self, line: str) -> None:
        self._lines.append(line)

    def _write_preamble(self) -> None:
        cfg = self.cfg
        if cfg.program_number is not None:
            self._emit(f"O{cfg.program_number:04d}")
        self._emit(comment("Generated by TormachCAM"))

        # Modal group initialization
        units_word = cfg.units.gcode_modal  # G20 or G21
        self._emit(
            f"G17 {units_word} G40 G49 {cfg.work_offset} G80 G90 G94"
        )
        # Path blending
        self._emit(f"G64 P{fmt(cfg.path_blend_tolerance)}")
        self._emit("")

    def _write_tool_change(self, tool_number: int) -> None:
        cfg = self.cfg
        self._emit(comment(f"Tool change: T{tool_number}"))
        self._emit("M5")                          # spindle off
        self._emit("M9")                          # coolant off
        self._emit("G30")                         # Tormach tool-change position
        self._emit(f"T{tool_number} M6")          # load tool
        self._emit(f"G43 H{tool_number}")         # tool length offset
        self._emit(f"S{cfg.rpm} M3")             # spindle CW
        if cfg.coolant:
            self._emit("M8")                      # coolant on
        self._emit(f"G4 P{fmt(cfg.spindle_warmup_dwell, 1)}")  # dwell

    def _write_toolpath(self, tp: Toolpath) -> None:
        if tp.is_empty:
            return

        self._emit("")
        self._emit(comment(f"Operation: {tp.operation_name}"))
        self._write_tool_change(tp.tool_number)

        # Move to safe Z before starting
        self._emit(rapid(z=self.cfg.rapid_z))
        self._emit("")

        for seg in tp.segments:
            if seg.is_empty():
                continue
            if seg.label:
                self._emit(comment(seg.label))
            for pt in seg.points:
                self._emit(self._format_point(pt))

        # Retract after operation
        self._emit(rapid(z=self.cfg.rapid_z))

    def _format_point(self, pt: ToolpathPoint) -> str:
        feed = pt.feed_rate
        if pt.move_type in (MoveType.RAPID, MoveType.RETRACT):
            return rapid(x=pt.x, y=pt.y, z=pt.z)

        if pt.move_type == MoveType.PLUNGE:
            line = linear(x=pt.x, y=pt.y, z=pt.z)
            if feed is not None:
                self._current_feed = feed
                return linear(x=pt.x, y=pt.y, z=pt.z, f=feed)
            return line

        # FEED
        if feed is not None and feed != self._current_feed:
            self._current_feed = feed
            return linear(x=pt.x, y=pt.y, z=pt.z, f=feed)

        return linear(x=pt.x, y=pt.y, z=pt.z)

    def _write_postamble(self) -> None:
        self._emit("")
        self._emit(comment("End of program"))
        self._emit("M5")   # spindle off
        self._emit("M9")   # coolant off
        self._emit("G30")  # return to tool-change position
        self._emit("M30")  # end of program
        self._emit("%")
